import os
import shutil
import sys
import json
import glob
import time

sys.path.append('../config')
sys.path.append('../scenario')

from client import Client
from config import configs
from networkPlayground import NetworkPlayground
from cryptography import Cryptography
from validator import ValidatorTwin
from pathlib import Path


class RunDiemBFT(process):

    def setup(config, config_id):
        self.nvalidators = int(config['nvalidators'])
        self.ntwins = int(config['ntwins'])
        self.nclients = int(config['nclients'])
        self.nfaulty = int(config['nfaulty'])
        self.isdone = False
        self.liveness_bound = 10

    def log(*args):
        with open('../Executorlogs/config_' + str(self.config_id) + '.log', 'a+') as f:
            sys.stdout = f # Change the standard output to the file we created.
            for x in args:
                print(x, end = ' ')

            print('')

    def run():

        start_time = time.time()
        
        private_keys_validators = {}
        public_keys_validators = {}
        private_keys_clients = {}
        public_keys_clients = {}

        private_key_list_validators = []
        public_key_list_validators = []

        id_to_validator_map = {}
        validator_to_id_map = {}
        id = 'A'

        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))

        play_ground = new(NetworkPlayground, num = 1)
        
        validators = list(new(ValidatorTwin, num=nvalidators))
        twins = list(new(ValidatorTwin, num=ntwins))
        clients = list(new(Client, num=nclients))

        self.log("Starting Executor")
        self.log("Spawning ", self.nvalidators, " Validators")
        self.log("Added Twinn for  ", self.nfaulty, " Validators")        

        for _ in range(nvalidators):
            private_key, public_key = Cryptography.generate_key()
            private_key_list_validators.append(private_key)
            public_key_list_validators.append(public_key)

        for i, v in enumerate(validators):
            private_keys_validators[v] = private_key_list_validators[i]
            public_keys_validators[v] = public_key_list_validators[i]
            id_to_validator_map[id] = v
            validator_to_id_map[v] = id
            id = chr(ord(id) + 1)

        for i, v in enumerate(twins):
            private_keys_validators[v] = private_key_list_validators[i]
            public_keys_validators[v] = public_key_list_validators[i]
            id_to_validator_map[id] = v
            validator_to_id_map[v] = id
            id = chr(ord(id) + 1)
            validators.append(v)

        for c in clients:
            private_key, public_key = Cryptography.generate_key()
            private_keys_clients[c] = private_key
            public_keys_clients[c] = public_key

        setup(play_ground, (config, config_id, id_to_validator_map, validator_to_id_map))
        start(play_ground)

        for i, v in enumerate(validators):
            setup({v}, (config, config_id, i, list(validators), list(clients),
                        private_keys_validators[v], public_keys_validators, public_keys_clients, play_ground, validator_to_id_map, id_to_validator_map))

        for i, c in enumerate(clients):
            setup({c}, (config, config_id, i, list(validators),
                        private_keys_clients[c], public_keys_validators))

        start(validators)
        start(clients)
        liveness_check()
        await(self.isdone == True)
        output("All rounds done, informing all validators.", config_id)
        self.log("All rounds done, informing all validators.", config_id)
        exit_executor(validators, clients, play_ground)
        end_time = time.time()
        self.log("Ending Executor", "Time elaped : ", end_time - start_time)
        

    def exit_executor(validators, clients, play_ground):
        send(('Done',), to=validators)
        send(('Done',), to=play_ground)
        send(('Done',), to=clients)
        time.sleep(2)
        output("Exiting Scenario Executor", os.getpid())
        self.log("Exiting Scenario Executor", os.getpid())
        safety_check()

    def receive(msg=('Done',), from_=p):
        self.isdone = True


    # Check for Safety After running for One Scenario
    def safety_check():
        ledger_dir = "../ledgers/config" + str(self.config_id)
        message_count = {}
        for x in os.walk(ledger_dir):
            for ledger in glob.glob(os.path.join(x[0], '*.ledger')):
                file = open(ledger)
                Lines = file.readlines()
                for line in Lines:
                    msg = line.strip()
                    if msg not in message_count:
                        message_count[msg] = 0
                    message_count[msg] = message_count[msg]+1
        
        for key, value in message_count.items():
            if value < 2 * self.nfaulty + 1:
                self.log("Safety Violated")
                return
        output(message_count)
        self.log(message_count)
        self.log("Safety Not Violated")


    def liveness_check():
        prev_count = -1
        while(self.isdone == False):
            self.log("Checking Liveness")
            ledger_dir = "../ledgers/config" + str(self.config_id)
            current_count = 0

            for x in os.walk(ledger_dir):
                for ledger in glob.glob(os.path.join(x[0], '*.ledger')):
                    file = open(ledger)
                    Lines = file.readlines()
                    current_count += len(Lines)
            if current_count == prev_count:
                self.log("Liveness bound violated")
                self.isdone = True
                break
            else:
                prev_count = current_count
            time.sleep(5)

def main():

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    if os.path.exists('../Executorlogs/') and os.path.isdir('../Executorlogs/'):
        shutil.rmtree('../Executorlogs')
    
    os.mkdir("../Executorlogs")

    if os.path.exists('../Playgroundlogs/') and os.path.isdir('../Playgroundlogs/'):
        shutil.rmtree('../Playgroundlogs')
    
    os.mkdir("../Playgroundlogs")

    config_id = 0

    for x in os.walk('../scenario'):
        for y in glob.glob(os.path.join(x[0], '*.json')):
            f = open(y)
            config = json.load(f)
            p = new(RunDiemBFT)
            setup(p, (config, config_id))
            start(p)
            config_id += 1
