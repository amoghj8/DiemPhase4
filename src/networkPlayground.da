PROPOSAL_MESSAGE = "Proposal"
VOTE_MESSAGE = "Vote"
TIMEOUT_MESSAGE = "Timeout"

class NetworkPlayground(process):

    def setup(config, id_to_validator_map, validator_to_id_map):
        print(id_to_validator_map)
        print(validator_to_id_map)
        self.isdone = False
        self.exclusion_map = self.config["exclusion"]
        pass

    def run():
        print("Playground Started")
        await(self.isdone == True)
        output("exit playground")

    def log(*args):
        with open('../Playgroundlogs/config_' + str(self.config_id) + '.log', 'a+') as f:
            sys.stdout = f # Change the standard output to the file we created.
            for x in args:
                print(x, end = '')

            print('')

    def get_partition(round, node):
        result = []
        if str(self.round) in self.config['round_partitions']:
            for partition in self.config['round_partitions'][str(self.round)]["Partition"]:
                if node in partition:
                    # print(partition)
                    for n in partition:
                        if n not in result:
                            result.append(n)
        return result

    def filter_exclusion(node_id, current_round, send_list, message_type):
        if str(current_round) not in self.exclusion_map:
            return send_list
        
        if node_id not in self.exclusion_map[str(current_round)]:
            return send_list

        result = []
        for dest in send_list:
            
            if '*' in self.exclusion_map[str(current_round)][node_id]:
                if 'messageType' in self.exclusion_map[str(current_round)][node_id]['*']:
                    loss_msg_type = self.exclusion_map[str(current_round)][node_id]['*']['messageType']
                    if message_type == loss_msg_type or loss_msg_type == "*":
                        continue

            if dest not in self.exclusion_map[str(current_round)][node_id]:
                result.append(dest)
                continue
            if 'messageType' not in self.exclusion_map[str(current_round)][node_id][dest]:
                result.append(dest)
                continue
            loss_msg_type = self.exclusion_map[str(current_round)][node_id][dest]['messageType']
            if loss_msg_type != message_type or loss_msg_type != '*':
                result.append(dest)

        return result



    def get_nodes_list(partition):
        lst = []
        for node in partition:
            lst.append(self.id_to_validator_map[node])
        return lst
    
    def fetch_next_leader(round):
        next_round = round + 1
        if str(next_round) in self.config['round_partitions']:
            next_leader = self.config['round_partitions'][str(next_round)]["Leader"]
            return next_leader
        else:
            return []

    def send_to_validators(msg_type, msg, src_node, dest_list):
        # send((msgType, msg, node), to = validator_to_id_map.keys())
        print("Sending ", msg_type, " from ", src_node, " to", dest_list)
        send((msg_type, msg, src_node), to = dest_list)
        
    def receive(msg=('Done',), from_=p):
        self.isdone = True

    def receive(msg=('Proposal', p_msg), from_=node):
        current_round = str(p_msg.block.round)
        node_id = self.validator_to_id_map[node]
        current_partition = get_partition(current_round, node_id)
        print("Proposal Message receive from ", node_id, " : Which is in the partition ", current_partition)
        filtered_nodes = filter_exclusion(node_id, current_round, current_partition, PROPOSAL_MESSAGE)
        nodes_list = get_nodes_list(filtered_nodes)
        send_to_validators('Proposal', p_msg, node, nodes_list)
        

    def receive(msg=('Timeout', t_msg), from_=node):
        current_round =  str(t_msg.tmo_info.round)
        node_id = self.validator_to_id_map[node]
        current_partition = get_partition(current_round, node_id)
        print("Timeout Message receive from ", node_id, " : Which is in the partition ", current_partition, " Round : ", current_round)
        filtered_nodes = filter_exclusion(node_id, current_round, current_partition, TIMEOUT_MESSAGE)
        nodes_list = get_nodes_list(filtered_nodes)
        send_to_validators('Timeout', t_msg, node, nodes_list)


    def receive(msg=('Vote', v_msg), from_=node):
        current_round = v_msg.vote_info.round
        node_id = self.validator_to_id_map[node]
        current_partition = get_partition(current_round, node_id)
        next_leader_list = fetch_next_leader(current_round)
        filtered_nodes = filter_exclusion(node_id, current_round, next_leader_list, VOTE_MESSAGE)
        nodes_list = get_nodes_list(filtered_nodes)
        send_to_validators('Vote', v_msg, node, nodes_list)


    def receive(msg=('Sync_Request', currentRound), from_=node):
        node_id = self.validator_to_id_map[node]
        print("Got Sync_Request Message from ", node_id, " for the round ", currentRound)
        current_partition = get_partition(currentRound, node_id)
        nodes_list = get_nodes_list(current_partition)
        send_to_validators('Sync_Request', currentRound, node, nodes_list)


    def receive(msg=('Sync_Reply', message, currentRound), from_=node):
        node_id = self.validator_to_id_map[node]
        print("Got Sync_Reply Message from ", node_id, " for the round ", currentRound)
        current_partition = get_partition(currentRound, node_id)
        nodes_list = get_nodes_list(current_partition)
        send_to_validators('Sync_Reply', message, node, nodes_list)